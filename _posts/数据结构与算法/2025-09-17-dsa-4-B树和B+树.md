---
layout: post
title: "B树和B+树"
category: "数据结构与算法"
order: "4"
math: true
---

### 为什么需要 B 树和 B+ 树

假设我们有 10 亿条记录，需要对其主键（primary key）建立索引。我们可以使用二叉树索引结构（例如二叉排序树、红黑树等）。我们暂时忽略索引结构本身带来的内存开销，考虑每条索引项（也就是每个二叉树结点）中，有 8 字节空间存储主键本身，有 8 字节存储一个指针，指向对应的完整记录在磁盘中存放的位置。这样，10 亿条索引项所需的总空间就至少是 16 GB。

这些索引数据是需要分块存放在磁盘上的。假设磁盘块大小是 4 KB，那么这些索引就占据了约四百万个磁盘块，每个磁盘块大约能存放 250 条索引项。当我们需要使用索引来处理查询时，尽管现代计算机的主存可以达到上百 GB，但是专门为一个数据库查询，就将 16 GB 的索引数据全量加载到主存中还是不合理的。所以实际上，这些索引数据是按需加载的。当我们需要访问索引结构中的索引项（二叉树中的结点）时，就需要将磁盘中对应的块加载到主存中。

考虑最坏的情况，即目标索引项恰好处于二叉树的叶节点上，那么包含 10 亿个结点的二叉树高度最小是大约 $\log_2 10^9 \qpprox 30$。这大约 30 个结点大概率是分别位于 30 个磁盘块上，因此这一次查询就至少需要读取 30 次磁盘。

而我们知道磁盘读写的开销是远远高于 CPU 指令运行的开销的，因此在设计二级存储读写的问题中，影响开销的主要因素是读写磁盘块的个数，而不是内存算法的复杂度。为了应对这一点，我们很容易能够想到的一个改进就是，降低索引树的高度。具体来说，二叉树结点的度数固定为 2，这太小了；如果我们能大大增加索引树结点的度数，例如增加到几百或几千，那么索引树的高度就会大大下降，最坏情况下读写磁盘块的数量也会下降。

### B 树

仅从树的形状上来说，一棵阶数为 $m$ 的 B 树（$m\geq 3$）是满足如下条件的有序树：

- 每个结点的度数不超过 m

- 除根结点外，每个内部结点的度数不小于 $\lceil m/2 \rceil$

- 所有的叶结点位于同一层

这样一来，如果我们建立阶数 $m=1000$ 的 B 树，具有 $n$ 个结点的树的高度就大致不超过 $log_{500} n$ 而不是 $\log_2 n$，这将 I/O 次数减小了 7 至 8 倍。同时，阶数也不宜过于大，极端情况下如果阶数本身已经达到了上百万千万，那么也失去了索引本身的意义了。

当然，我们将树的结点的度数扩充了，键值在树中的组织方式也需要调整。在二叉树中，基本的原则是对于每个结点而言，左子结点键值 < 自身键值 < 右子结点键值。但当一个结点有多个子结点时，该将自身的键值排在什么位置呢？对于这一问题，我们的解决方式是，如果一个内部结点具有 $d$ 个子结点 $s_1, \cdots, s_d$，那么这个结点本身就应该恰好容纳 $d-1$ 个键值 $k_1, \cdots, k_{d-1}$，满足

$$
s_1.keys < k_1 < s_2.keys < k_2 < \cdots < k_{d-1} < s_d.keys
$$

这里 $s_1.keys$ 等表示子结点拥有的全部键值。

另一个问题是，叶结点不具有子结点，那么它该容纳多少个键值呢？根据上面的定义，$m$ 阶 B 树的内部结点最多容纳 $m-1$ 个键值，因此我们同样规定，叶结点也最多容纳 $m-1$ 个键值。否则大量键值堆积在一个叶结点也是不合适的。同时，我们也规定叶结点最少容纳 $\lceil m/2 \rceil - 1$ 个键值。

### B 树的增删改查

查询：增删改查的核心是查询，实现了查询，其他的操作只需要处理各自的细节即可。B 树的查询与二叉树索引结构的查询类似，从根结点开始比较。如果当前结点中包含待查询的键值（与二叉树不同，二叉树没有包含一说，因为每个结点只有一个键值），那么查询结束。否则，就可以根据待查询键值所在的区间，查询对应的子结点。如果已经到达叶结点，就表明查询失败。

增加：首先对待增加结点执行一次查询。如果查询成功，那表明索引重复了，拒绝插入；否则如果查询失败，那么查询过程也确定了，该结点应该插入的位置，也就是查询最后的叶结点。（如果允许索引项重复的话，也是确定了插入位置）将键值加入到这个叶结点中的合适位置，这会让叶结点包含的主键数量加一。如果这没有违反 $m-1$ 个主键的上限的话，插入就完成了；如果主键数量达到了 $m$ 个，就需要将这个叶结点平分为两个结点。具体来说，要首先找到叶结点的中位键值，提升为父结点的键值；然后将左右两侧的键值放在两个结点中，连接到（提升为父结点的）中位键值的左右两侧。递归地，这会使父结点的度数加一，如果违反了上限也需要分裂。直到根节点处，根节点分裂后会形成新的树根，这会使 B 树的高度加一，分裂过程停止，这也是树的高度增加的唯一方式。值得一提的是，即使插入数据时高度有序的，B 树也不会发生退化，高度增长速度仍然稳定。

删除：首先对待删除结点执行一次查询。如果查询失败，那表示出错了；查询成功的话就定位了键值的位置。如果键值在叶结点上，那么将它直接删去。如果键值在内部结点上，那么就寻找该键值的后继（即右子树中的最左子结点，一定是叶结点），将后继删除，同时将待删除的键值替换为后继键值。（这与二叉树的删除类似，而且也可以使用前驱而不是后继）

然后，我们要关注是否有叶结点的键值数违反了规定，即小于 $\lceil m/2 \rceil - 1$。如果有违反，我们优先会考虑它的兄弟结点是否有富余的键值，如果有的话，我们就可以在局部进行一个平移，从兄弟结点借入一个键值（这一步也需要涉及到父结点）。如果兄弟结点都达到了紧约束，也就是都仅有 $\lceil m/2 \rceil - 1$ 个键值了，那么就把它与一个兄弟合并，也就是将两个兄弟结点的所有键值，连同父结点中的一个键值，合并为一个子结点，它具有的键值数是 $2 * \lceil m/2 \rceil - 2 \leq m - 1$。递归地，它们的父结点的键值数和度数就减一，同样可能违反限制，因此需要向上调整。直到根节点的度数减一，就不需要调整了，因为根节点没有最少度数限制。特别地，如果根节点的度数因此减为 0 了，B 树的高度也就减小了。

### B+ 树

然而，当我们在实际工程谈论 B 树时，我们往往说的是 B+ 树。几乎没有人使用 B 树了。B+ 树与 B 树的区别就是，在 B+ 树中，所有键值必须存放在叶结点中，而内部结点中存储的键值仅是一个副本。这带来了若干条好处：

- 更方便范围查询：由于所有键值都在叶结点上，因此可以构建叶结点链表。像 “between 100 and 200” 这样的查询就可以查询一端，然后遍历链表。否则，使用 B 树将不得不对局部的子树进行遍历，I/O 次数大大增加。

- 更高的扇出（Fan-out）：B 树的内部结点代表键值，就需要存储指向记录的指针；B+ 树的内部结点省去了这一点，只有叶结点需要存放指向记录的指针。同时我们需要理解，一个树中的一个结点大小最好与磁盘块大小吻合。一方面，我们读取一个结点就需要一次磁盘I/O。这个结点是几字节大，还是接近一个磁盘块大，都不影响读取的开销，而显然后者获取的信息更多更划算。另一方面，结点大小最好不超过磁盘块大小，否则读取一个结点就需要多次I/O了。这种情况下，B+ 树的结点就能够在同样的容量之内存储更多的键值，让树的宽度更大，高度更小。

- 查询性能更稳定：B+ 树中的任何查询都走到叶结点层，而 B 树的查询可能在较浅的结点就命中。

- 更容易进行并发控制：当利用索引并发读写数据时，要对索引项加锁，互斥锁会严重影响并发。B 树中的数据修改可能发生在任意层级，高层内部结点加锁会导致更严重的锁冲突，而 B+ 树中的数据修改主要在叶结点发生。

### B+ 树的增删改查

查询：与 B 树基本相同，不同点在于，结点中如果存在一个键值 $k$，那么它的含义是左侧子树中的键值都 $< k$，而右侧子树的键值 $\geq k$，键值 $k$ 本身就出现在右侧子树中。

增加：与 B 树基本相同，不同点在于，进行结点分裂时，B 树将中位数键值提升到父结点，而 B+ 树会将中位数结点保留在一个右侧子结点中，而在父结点中插入中位数键值的拷贝。

删除：与 B 树区别较大。首先，B+ 树的删除不会发生在内部结点上。另外，在叶结点的度数违反限制时，二者的处理方式有所不同。当兄弟结点具有富余的键值时，这一调整需要改变父结点中对应的导航值，而这可能需要递归地向上调整；当兄弟结点没有富余键值，进行合并时，不会加上父结点的导航值。父结点失去导航值后同样可能要递归向上调整。