---
layout: post
title: "二项堆和斐波那契堆"
category: "数据结构与算法"
order: "2"

---

### 二项树

二项树是有序树，其递归定义为，$B_0$ 只有一个根节点，$B_{k+1}$ 由两棵二项树 $B_k$ 组成，组成方式为一棵树的根节点作为另一棵树的最左子结点。根据这个定义，每一阶二项树都是唯一的。可以容易地验证和证明如下性质：

- $B_k$ 的度数为 $k$，且只有树根的度数为 $k$
- $B_k$ 的高度是 $k$
- $B_k$ 中共包含 $2^k$ 个结点

下图展示了二项树的具体形态

<img src="/assets/ds/二项树.png" alt="二项树" style="zoom: 67%;" />

### 二项堆

二项堆数据结构包含一个由二项树组成的森林。忽略简单的或不太重要的操作，二项堆主要支持以下两个操作

- Insert，向二项堆中插入一个关键码值
- Extract-Min，获取二项堆中的最小值并将其删除

与二叉堆相同，二项堆也要求每个结点的子结点的关键码值都不小于自身的关键码值。这样，任何一棵子树的最小值总是树根。

与二叉堆不同的是，由于二项堆放松了完全二叉树的结构限制，它就无法采用数组的顺序存储方式。二项堆采用链式存储：

- 每个结点存储一个指向最左子结点、父结点、右兄弟结点的指针
- 所有兄弟结点之间用双向循环链表连接
- 所有根节点也视为兄弟结点，用链表连接起来
- 另外，维护一个指针指向具有整个森林中的最小值的根结点

#### Insert

二项堆的 Insert 操作十分简单，就是新创造一个根结点，并与当前的最小根节点比较，更新最小根节点。

#### Extract-Min

Extract-Min 操作分两步，删除和清理。删除过程包括，将当前的最小根节点删除，将它的所有子树的根都加入到根链表中。

清理过程的目标是，合并阶数相同的二项树，直到森林中没有两棵二项树的阶数是相同的。

- 为了实现这一过程，我们可以设置一个列表，其下标为二项树的阶数。
- 遍历根链表，对于每个根节点，根据其阶数（就等于根节点的度数）将它加入到列表的对应位置
- 如果该位置上已经存在一棵树，就合并这两棵树，得到一棵阶数更高的树。然后尝试插入列表中的下一个位置。
- 合并的过程需要比较两颗树的根节点关键码值，较小的作为根节点。
- 合并结束后，在所有二项树中找出根节点的最小值，将维护最小值的指针指向根节点。

- 设置这个列表时我们需要知道，最大的阶数是多少。我们在此给出一个上界：如果结点的总数是 $n$，则最大阶数 $D(n)$ 不超过 $\lfloor \log n\rfloor$。这一点很容易证明，因为阶数为 $k$ 的二项树具有 $2^k$ 个结点。

#### 复杂度的摊还分析

我们使用势函数来进行上述两种操作的复杂度摊还分析。首先考虑实际代价

- Insert 操作的实际代价可以认为是 1
- Extract-Min 的删除过程的实际代价与根节点的度数有关，上界是 $D(n)$
- Extract-Min 的合并过程的实际代价，可以用合并操作的次数 $m$ 来表示。

我们期望的摊还代价是，Insert 的摊还代价为 $O(1)$，Extract-Min 的摊还代价为 $O(\log n)$。粗略地看，Insert 需要为 Extract-Min 的合并过程承担代价。与此相关的要素就是二项堆中树的数量：Insert 的根结点越多，合并过程的代价可能就越高。

因此，我们定义势函数为
$$
f(H)=t(H)
$$
其中 $t(H)$ 表示二项堆 $H$ 包含的二项树的数量。在这一势函数下

- Insert 操作使势函数增加 1，其摊还代价为 2，是 $O(1)$ 的
- Extract-Min 的删除过程使势函数至多增加 $D(n)-1$，合并过程使势函数减少 $m-1$。因此其摊还代价不超过 $D(n)+m+D(n)-1-(m-1)=2D(n)$，即 Extract-Min 的摊还代价是 $O(\log n)$ 的

### 斐波那契堆

斐波那契堆包含一个由有序树组成的森林。这些有序树是基于二项树的改进，并保证了一个关键性质：$n$ 个结点的堆中，树的最大度数 $D(n)=O(\log n)$。不考虑简单或者不重要的操作，斐波那契堆支持以下的操作

- Insert，向斐波那契堆中插入一个元素
- Extract-Min，获取堆中的最小元素，并将其删除
- Decrease-Key，将堆中指定的元素的关键码值减小
- Delete，删除堆中指定的元素。

注：对于 Decrease-Key 和 Delete 操作，“堆中指定的元素” 表示这些操作接收一个指向元素的指针。否则，就还需要根据元素的某个属性先找到这个元素，这个过程需要借助索引结构实现，与我们关注的内容无关。

另外，Delete 操作其实是 Decrease-Key 和 Extract-Min 的复合操作。先把目标元素的键值减小为负无穷，再删除最小值即可。这就是 Delete 操作比较高效的实现方式。因此下面的讨论就忽略这个操作。

斐波那契堆的存储结构与二项堆相同，其具体区别在于

- 斐波那契堆中的每个结点额外具有一个标记位属性 marked，初始值为 False。其含义为，该结点的子树是否曾经被删除过。Decrease-Key 和 Delete 操作会使用这一属性

#### Insert

与二项堆相同。Insert 操作仍然是创建一个新的根节点，然后尝试更新最小值结点

#### Extract-Min

与二项堆相同。Extract-Min 操作包含删除和合并两个过程，每个过程的做法是相同的。

#### Decrease-Key

Decrease-Key 操作首先改变目标结点的关键码值。如果没有破坏堆性质，则操作结束。否则就需要对堆结构进行调整

- 将目标结点从其父结点上删除
- 进行递归删除：如果原父结点的 marked 标记位已经被设为 True，就将父结点从祖父节点上删除，然后递归删除祖父节点。
- 递归过程沿着树的父子关系不断向上进行，直到某个结点的父结点初始的标记位为 False，这时将其设为 True 就可以停下；或者到达了根节点，根节点可以失去多棵子树，无需删除，也无需设置标记。
- 被删除的结点连同其所有子树加入到根链表中，marked 属性恢复 False，并尝试更新堆的最小值根 

#### 复杂度的摊还分析

我们依然使用势函数来分析复杂度。先考虑各个操作的实际代价

- Insert 操作的实际代价为 1
- Extract-Min 操作的实际代价分为两部分。删除过程的实际代价上界为最大度数 $D(n)$，合并操作的实际代价为合并次数 $m$
- Decrease-Key 操作的实际代价为递归删除的次数 $p$

从二项堆的摊还分析方法中，我们知道通过考虑堆中树的数量，可以将 Extract-Min 中合并操作的代价摊销到 Insert 操作上。但 Decrease-Key 的引入带来了新问题：

- 需要考虑 $p$ 的上界，或者先后的 Decrease-Key 操作的摊销关系
- Decrease-Key 也会增加树的数量，这意味着 Extract-Min 的合并过程还需要 Decrease-Key 来承担代价
- 需要重新考虑 $D(n)$ 的上界，并说明它仍然是对数的

对于第一个问题的分析如下：

- Decrease-Key 操作中  $p$ 的具体取值取决于，目标结点到根的路径上有多少个连续的 marked 标记。每多一个 marked 标记，就要多删除一次。
- 需要注意到以下两点：每删除一次，marked 标记就减少一个；每次 Decrease-Key 操作至多新增加一个 marked 标记。
- 所以，我们会把 marked 标记也加入到势函数中，实现 Decrease-Key 操作自身的摊销。
- 一次进行了 $p$ 个删除的 Decrease-Key 操作会使 marked 标记减少至少 $p-2$ 个，摊还代价是 $O(1)$ 的

对第二个问题的分析如下：

- 摊销 Extract-Min 的合并代价，就是承担树的数量增加带来的摊还代价
- 每次删除就会使树的数量增加 1，由此带来的摊还代价是 $p$，这样一来 Decrease-Key 的代价又与 $p$ 有关了
- 采取同样的方式把这部分代价也摊销了，也就是在势函数中再加入一份 marked 标记的数量。这使得摊还代价减少至少 $p-2$

对第三个问题的分析如下是最复杂的，也是斐波那契堆与斐波那契数的联系所在

- 我们想要说明，包含 $n$ 个结点的斐波那契堆的最大度数 $D(n)=O(\log n)$。

- 我们先说明，斐波那契堆中的任意一棵度数为 $k$ 的树或子树，其可能包含的结点的最小数量 $F(k)$ 在 $k$ 足够大时不小于 $c\phi^k ,(\phi >1, c>0)$ 。也就是，$F(k)$ 是指数增长的。这样，包含 $n$ 个结点的堆可能包含的最大度数就不超过 $\log_{\phi} n/c$，也就是 $O(\log n)$

- 首先回顾二项树，对于 $k$ 阶二项树，根结点的度数为 $k$，它的所有子结点从右到左度数依次为 $0, 1, \cdots, k-1$。成立 $F(k)=\sum_{i=0}^{k-1}F(i)+1$，其中 $F(0)=1$，因此 $F(k)=2^k$

- 对于斐波那契堆，有 $F(0)=1$，但不成立 $F(k)=\sum_{i=0}^{k-1}F(i)+1$，原因在于根节点的子结点度数可能不是 $0, 1, \cdots, k-1$。下面来考察从右到左计数的第 $i$ 个子结点的度数，$i$ 从 1 计数。

- 靠左侧的结点是后加入的，靠右侧的结点是后加入的，删除子结点不会改变这一点。所以第 $i$ 个子结点加入时，它右侧的 $i-1$ 个子结点已经存在

- 加入一个结点的唯一途径就是 Extract-Min 的合并操作，而这个合并操作只会合并度数相同的两个结点。上面说明了第 $i$ 个子结点在加入时，父结点至少具有 $i-1$ 个子结点。（父结点此时也可能具有 $i$ 个子结点，然后在后续失去了一个子结点，导致我们考察的子结点成为了第 $i$ 个子结点）所以，第 $i$ 个子结点加入时的度数至少是 $i-1$

- 第 $i$ 个子结点最多失去一棵子树，所以在任何时候第 $i$ 个子结点的度数至少是 $i-2$

  <img src="/assets/ds/斐波那契树.png" alt="斐波那契堆" style="zoom: 50%;" />

- 因此
  $$
  F(k) = \sum_{i=1}^kF(i-2)+1 =F(k-2)+\sum_{i=1}^{k-1}F(i-2)+1 = F(k-2)+F(k-1)
  $$
  且 $F(0)=1, F(1)=2$。因此 $F(k)$ 就是斐波那契数列的移位，有
  $$
  F(k)=\frac{1}{\sqrt{5}}(\phi_1^{k+2}-\phi_2^{k+2}), \quad \phi_1=\frac{\sqrt{5}+1}{2}, \phi_2=\frac{-\sqrt{5}+1}{2}
  $$
  为了证明 $F(k)$ 是指数增长的，可以归纳证明 $F(k)\geq \phi_1^k$，归纳基础省略。归纳推理为
  $$
  F(k+1)=F(k-1)+F(k)\geq \phi_1^{k-1}+\phi_1^k=\phi_1^{k-1}\times(1+\phi_1)=\phi_1^{k+1}
  $$
  其中用到了 $\phi^2=\phi+1$

- 这样就说明了 $D(n)=O(\log n)$

基于上面的分析，我们定义势函数为
$$
f(H)=t(H)+2M(H)
$$
其中 $t(H), M(H)$ 分别表示斐波那契堆中树的个数和标记的个数。

- Insert 的摊还代价为 $1+1=O(1)$。
- Extract-Min 的摊还代价为 $D(n)+m-(m-1)=O(\log n)$

- Decrease-Key 的摊还代价为 $p+p-2(p-1)=O(1)$