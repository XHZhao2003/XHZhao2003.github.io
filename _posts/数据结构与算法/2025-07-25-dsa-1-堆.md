---
layout: post
title: "堆与优先队列"
category: "数据结构与算法"
order: "1"
math: true
---



### 二叉堆 (heap)

二叉堆作为一种数据结构，支持以下几种操作：

- Build-Min-Heap，复杂度为 $O(n)$ ，从无序的输入数组中构造一个最小二叉堆
- Insert，复杂度为 $O(\log n)$，向最小二叉堆中插入一个元素
- Extract-Min，复杂度为 $O(\log n)$，删除最小二叉堆中最小的元素
- Decrease-Key，复杂度为 $O(\log n)$，减小二叉堆中指定元素的键值

下面是几点说明：

1. 复杂度中的 $n$ 表示二叉堆中的元素数量。对于 Build-Min-Heap 操作，指的是输入数据的数量
2. 二叉堆分为最小二叉堆和最大二叉堆，但二者无本质上的不同。如果是最大堆，则对应操作改为 Build-Max-Heap，Extract-Max，Increase-Key。
3. 概念上讲，二叉堆中的每个元素是一个结构体，具有不止一个属性。其中用来定义大小关系的属性称为键值（Key）。Decrease-Key 操作指的就是，通过其他的属性唯一指定一个元素，并减小该元素的键值。

可以发现，二叉堆操作的特别之处就在于 Extract-Min 操作。该操作不是线性复杂度的，而是对数复杂度的。二叉堆的设计都是围绕着这一目的，也就是 Extract-Min 展开的。

### 二叉堆的存储

二叉堆利用了完全二叉树来存储数据。完全二叉树是指这样的二叉树，除最后一层外每一层都是满的，且最后一层的结点从左到右连续排列。因此，完全二叉树可以用数组来存储。根节点的索引值为 0。对于索引值为 $i$ 的结点，其左右子女（如果存在）的索引值分别为 $2i$，$2i+1$。

为了能够维护堆中的最小值，二叉堆必须满足堆性质：对于除了根节点外的任何结点，其关键码值不小于其父结点的关键码值。这样，反过来说，任何一个结点的关键码值，都是以该结点为根节点的子树中，所有结点关键码值的最小值。所以根节点的关键码值就是最小的。

以上两点构成二叉堆的两条基本性质：完全二叉树性质，堆性质

### Build-Min-Heap

Build-Min-Heap 操作接收一个无序数据的数组。注意，这个数组可以被看成是完全二叉树，所以也可以说这个操作接收一个不满足堆性质的完全二叉树。这个操作要做的，就是把这棵完全二叉树调整至满足堆性质。

为了使其满足堆性质，我们需要保证每个结点与其子女的大小关系，也就是，如果发现父结点大于子结点，就把父结点与子结点交换位置。

我们选择自底向上的调整顺序，也就是，从堆中的最后一个内部结点（度数不为 0 的结点）出发，其索引为为 $\lfloor n/2 \rfloor -1$，逆序调整所有的内部结点。这个过程中需要注意一个问题：当我们交换了一对结点时，我们把较大的父结点与较小的子结点交换。尽管在原父结点的位置上，堆性质被满足了，但在原子结点的位置上，堆性质有可能被破坏，因为这个位置上的值变大了，有可能超过它的子结点。

使用相反的调整顺序并不能避免这个问题，如果我们从根节点出发，依次调整到最后一个内部结点，当我们交换一对结点时，父结点的位置上值变小了，这对于父结点的父结点来说是一个威胁，因为更新之后的值有可能小于它，从而打破它的堆性质。

所以，让我们暂时先关注自底向上的调整顺序。为了弥补上述问题，我们在交换一堆结点时就不能简单地仅考虑交换父子两个结点，而是还要考虑交换后的子结点与下一层结点之间是否还满足堆性质，如果不满足则需要继续交换。这个过程要一直持续，直到二叉树的最底层。这个过程称为 Sift-Down，因为这个过程其实就是，一个关键码值较大的结点，沿着二叉树中的路径一路向下，直到下面的结点的关键码都比它大，或者到达了底部，它就可以停止了；这一过程就像水中气泡的上浮，只不过这里是向下”浮“，也就是下浮。

让我们总结一下这个过程

- 从最后一个内部结点开始，按索引值的逆序遍历到结点，对每个结点执行 Sift-Down 调整操作。
- Sift-Down 操作：比较该结点与其所有子结点的关键码值，如果其自身是最小的，则操作结束；否则，将关键码值最小的结点与其交换位置，并对这个新的子结点执行 Sift-Down 操作。

让我们分析一下这整个过程的复杂度。简单来看，这里面共对 $O(n)$ 个内部结点进行了调整，对于每个结点的 Sift-Down 调整，在最坏情况下的递归深度是树的高度，也就是 $O(\log n)$，因而整个过程的复杂度是 $O(n\log n)$。这个推理是正确的，但问题在于这个渐进界不是最紧的。从最开始我们就知道，我们要在 $O(n)$ 的复杂度内完成建堆。实际上，这个过程的复杂度就是 $O(n)$。

我们可以将分析精细化到树中的每一层。在高度为 $h$ 的结点上，Sift-Down 的代价是 $O(h)$。堆的高度为 $\lfloor \log n\rfloor$，而高为 $h$ 的一层上最多有 $2^{\lfloor\log n \rfloor -h}$ 个结点，因此总代价可以表示为
$$
\sum_{h=0}^{\lfloor \log n \rfloor}2^{\lfloor \log n \rfloor - h}\times O(h) 
=O(n)\times \sum_{h=0}^{\lfloor \log n \rfloor}\frac{h}{2^h}=O(n)
$$
其中用到一个级数求和
$$
\sum_{h=0}^{\infty} \frac{h}{2^h}=2
$$
这样就得到了 $O(n)$ 这一渐进界。关键在于，树中较低的层具有较多的结点，而对它们的调整次数较少；而树中较高的层具有较少的结点，而对它们的调整次数较多。

现在我们可以再考虑一下自上而下的调整方式。为了解决后来的调整可能破坏先前的调整的问题，我们比较每个结点时就需要做 Sift-Up 操作，也就是把较小的值不断向上传递，从而确保先前调整的位置的堆性质能够保持。这样一来，越是较低的层，最坏情况下的调整次数就越多，复杂度就真变成 $O(n\log n)$ 了。

### Insert 

现在我们有了一个二叉堆。在对其进行调整（Insert，Extract-Min，Decrease-Key）时，我们主要是考虑，如何在实现这个操作的同时，避免破坏堆的性质，或者修复可能被破坏的堆性质。

为了插入一个元素，我们会向将它插入在数组的末尾，也就是完全二叉树的最后一层的最后一个结点之后。这样首先使完全二叉树性质不被破坏。但是，这个新插入到最底层的关键码值可能非常小，以至于它破坏了它的父结点的堆性质。因此，我们对它执行 Sift-Up 操作：如果它的关键码值小于父结点，就交换二者；然后继续与新的父结点比较，直到它的关键码值大于等于父结点，或者到达了根节点。

总结一下，插入操作就是，将新节点插入到堆的末尾，然后执行 Sift-Up 操作。复杂度显然是 $O(\log n)$。

### Extract-Min

为了删除堆中的最小值，我们现在知道，就只需要删除堆的根节点，也就是数组中索引为 0 的结点。问题在于，这样一来完全二叉树性质被破坏了，所有结点不是从 0 索引开始连续存储的了。

为了方便地解决这个问题，我们把数组中的末尾元素放置到根节点的位置上。这样的代价是，根节点的位置上大概率不满足堆性质；但同时，整个二叉树中的其他所有位置的堆性质都没有被打破。而我们已经对修复堆性质的方法非常熟悉：只需要对这个新的根节点执行 Sift-Down 调整即可。

这一操作的时间复杂度是 $O(\log n)$。

### Decrease-Key

严格来说二叉堆本身并不需要支持 Decrease-Key 操作。但是二叉堆与优先队列几乎是同一回事，而优先队列对 Drcrease-Key 操作的使用是很常见的。另一方面，Decrease-Key 操作对于本身就有些难以理解，所以先举一个优先队列的应用例子。

一个任务调度器可能每秒接收成百上千个待处理的任务，每个任务都具有一个优先级。任务调度器每隔一个固定时长就需要找出当前排队等候处理的任务中，优先级最高的那一个。为了方便起见，我们把优先级定义为整数，数值越低表示优先级越高。另一方面，为了唯一确定地指代每个任务，每个任务都有一个唯一编号 TID。这样，每个任务就至少具有两个属性：优先级（关键码）和 TID。

任务调度器可以用一个最小堆来存储待处理的任务。当新任务到来，它就执行 Insert 操作；当内置固定时刻到来，它就执行 Extract-Min 操作来给出当前要处理的任务。

一个容易想象的场景是，用户发现 TID=42 号任务在任务队列中已经排队了很久，于是临时决定提升它的优先级。

这就是 Decrease-Key。从堆这一数据结构的视角来看，就是通过元素的唯一标识指定一个元素，并减小它的关键码值。增加关键码值也是类似的，只不过调整的方向不同，就像最小堆和最大堆的区别一样，所以我们只考虑减小键值的操作。

对这个元素的调整操作本身是非常简单的。如果它的关键码值变小了，那么就应该对它执行 Sift-Up 操作，时间复杂度是 $O(\log n)$。但一个问题是，这个操作要求通过唯一标识（上面的例子中，TID）指定元素，所以我们在调整前得需要定位这个元素在堆中的位置。

所以这是一个检索问题。最低效的做法是遍历堆数组来找到这个元素，这会使复杂度退化到 $O(n)$。一种高效方案是使用哈希表，这样检索过程的代价可以认为是 $O(1)$ 的。更特殊但也很常见的情况是，元素的唯一标识就是自然数序列。这种情况下，只需要使用额外 $O(n)$  的空间，存储一份每个元素在堆中的位置索引即可。例如，当要对 TID=42 号元素进行 Decrease-Key 操作时，我们就首先查看索引数组的 42 号元素，得知其在堆数组中的索引，然后执行 Sift-Up 即可。

要注意的是，当我们为堆新引入了一个索引结构时，堆的其他操作也都需要维护这个索引。好在对于每个元素的单次调整，我们都可以以 $O(1)$ 的代价完成其索引的调整：通过其唯一标识，我们可以定位到其在索引结构中的位置，然后将其旧索引改为新索引即可。所以这对之前所有操作的复杂度没有影响。

总结一下，Decrease-Key 操作就是，使用哈希表或者简单数组来维护堆中元素的索引，使用这个索引找到指定的元素，然后执行 Sift-Up 调整。时间复杂度为 $O(\log n)$



