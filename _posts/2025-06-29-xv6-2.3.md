---
layout: post
title:  "2.3 内核组织"
category: "xv6-book"
order: "10"
---

内核设计的关键问题是，要把操作系统的哪些部分放在特权模式下执行。一种可能是，整个操作系统都在内核中，也就是所有系统调用都在特权模式下执行。这种组织方式被称为宏内核（monilithic kernel）。

这种组织意味着整个操作系统都具有完全的硬件特权。这方便了操作系统的设计者，他们不需要再考虑哪些部分不需要硬件特权、哪些部分需要硬件特权了，而且，操作系统的各部分要协同工作也更容易了。例如，操作系统的文件系统和虚拟内存系统可以共享同一个缓冲区缓存。

宏内核设计的缺点在于，操作系统的各部分通常都很复杂（我们接下来就会看到），导致操作系统的开发者很容易犯错。宏内核组织下，内核的错误是致命的，因为特权模式下发生的错误通常会导致内核故障。而内核一旦故障，计算机和所有应用程序也都跟着故障了。这时候就不得不重启计算机。

为了减少内核出错的风险，操作系统设计者可以尽可能地减少运行在特权模式下的操作系统代码。这意味着操作系统的主体都是运行在用户模式下的。这种内核组织方式称为微内核（microkernel）。

![figure2.1](../assets/xv6/figure2.1.png)*图 2.1：具有一个文件系统服务器的微内核*

图 2.1 展示了这种微内核设计。图中的文件系统是一个用户级的进程，操作系统的各项服务都以服务进程（server）的方式存在。要让应用程序能够与文件系统服务器交互，内核提供了一个进程间通信的机制，即让一个用户模式的进程像另一个用户模式的进程发送信息。例如，如果 Shell 程序想要读写一个文件，他就像文件系统服务器发送一个信息，然后等待它的回复。

微内核中，内核接口只包括几个用来启动程序，发送信息，访问硬件设备等的低级函数。这样的组织方式是内核变得相对简单，因为操作系统的大部分都是用户级的服务器。

现实世界中，宏内核和微内核都很流行。大部分 Unix 内核是宏内核。Linux 就是宏内核，尽管它的一些诸如窗口系统的功能也是以用户级服务器的形式运行的。Linux 对于操作系统敏感的程序能表现出较高的性能，部分原因在于，可以把 Linux 内核的子系统紧密集成起来。

Minux, L4, QNX 等操作系统是以微内核+服务器的形式组织的，并在嵌入设备中被广泛部署。L4 的一个变种  seL4 非常小，以至于人们已经验证了它的内存安全性以及其他安全性质。

关于宏内核和微内核哪种更好的争论很多，但目前没有决定性的论据。而且，这也取决于如何定义“好”：可以是更快的性能，更小的代码体积，内核的可读性，整个操作系统的可靠性（包括用户级服务），等等。

相比于选择哪种组织方式，人们可能更关心实践中的考虑。例如，一些操作系统具有微内核，但出于性能的考量，它同时也在内核空间运行一些用户级服务。有一些操作系统具有宏内核，原因仅仅是起步时选择了宏内核；而且他们也没有动力转向微内核，因为开发者关心的主要是给系统添加新特性，而不是重写整个系统来适配微内核设计。

从本书的视角来看，宏内核和微内核具有非常多相同的核心概念。它们都实现系统调用，都使用页表，都处理终端，都支持进程，都用锁来控制并发，都实现了文件系统，等等。本书关注这些概念本身。

与大多数 Unix 操作系统相同，xv6 是以宏内核实现的。因此，xv6 的内核接口就是操作系统接口，内核实现了操作系统。由于 xv6 只提供了少量服务，它的内核甚至比一些微内核还要小，但概念上它仍然是宏内核的。