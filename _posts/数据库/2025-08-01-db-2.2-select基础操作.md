---
layout: post
title:  "2.2 基本查询：select"
category: "数据库"
order: "4"
---

### 基本查询：select

**简单查询**：考虑“找出所有教师的名字”，这个查询的命令是

```sql
select name from instructor;
```

它的一般形式是 `select A from r;`，其中 A 是 r 的属性。这个查询会返回一张表，只包含 instructor 表的 name 一列。

考虑这个命令

```sql
select dept_name from instructor;
```

它返回的就是 instructor 表的 dept_name 列。注意，尽管很可能这一列的大部分值都是重复的，因为大学的院系总共就那么几个，但这个运算不会帮你自动去重。原表中是什么样，它就返回什么样。

**去重 distinct**: 在 select 后加上 distinct 关键字，或者 all 关键字，来指明要求去重或者不去重。

```sql
select distinct dept_name from instructor;
select all dept_name from instructor;
select dept_name from instructor;
```

第一条命令会按 dept_name 进行去重，后两条命令的结果是相同的。

**属性的派生值**: select 命令还可以用于计算属性的派生值并返回。例如

```sql
select ID, name, dept_name, salary * 1.1 from instructor;
```

- 这条命令的结果是一个与 instructor 相同的表，除了 salary 属性都变成了 1.1 倍
- salary * 1.1 就是 salary 属性的派生值
- ID, name, dept_name, salary * 1.1 这个元组可以看成是原表中 4 个属性的派生值，通过连接运算产生。这样，就可以从 select 命令获取多个列。
- 其他的派生操作包括加减乘除等算术表达式

**where 谓词**: where 谓词字句允许我们筛选出满足特定谓词条件的元组。例如

```sql
select name from instructor
where dept_name = 'Comp. Sci.' and salary > 70000;
```

- 该命令返回 Computer Science 院系中薪水大于 70000 的所有教师的名字。
- where 子句写在 from 之后，是一个包含属性的条件判断语句
- 谓词语句可以由多个简单的子句通过 and, or not 复合而成。
- 每个子句通常是使用 <, <=, >, >=, =, <> 的比较表达式

**from 多关系：笛卡尔积**：大多数查询可能需要利用多个表的信息，例如 “找出所有教师的名字，以及他们的院系名称，以及所在建筑的名称”，这个操作的命令是

```sql
select name, instructor.dept_name, building
from instructor, department
where instructor.dept_name = department.dept_name
```

- 这个命令逻辑上的执行顺序是 from 子句、where 子句、select 子句。所有查询命令的顺序也都是这样的。
- from 语句会计算两个关系的笛卡尔积，也就是，将第一个关系中的每个元组与第二个关系中的每个元组连接。参与笛卡尔积运算的两个关系是 
  - instructor(ID, name, dept_name, salary)
  - department(dept_name, building, budget)
  - 结果是匿名关系 (instructor.ID, instructor.name, instructor.dept_name, instructor.salary, department.dept_name, department.building, department.budget)
  - 该关系中的属性都带有原关系名作为前缀，以便区分重名的属性。对于没有重名发生的属性，可以使用带有前缀的属性名指代，也可以使用原属性名指代。
- where 语句挑选出 instructor.dept_name = department.dept_name 的元组。笛卡尔积运算产生了大量无意义的元组，只有这样的元组才是有意义的。
- select 语句挑选出我们要求的结果输出

**from 多关系：自然连接**：使用笛卡尔积连接多个关系是低效的。最常见的情况是，两个表具有公共属性，并且只有公共属性相同的元组连接起来才有意义。这个操作就是自然连接。例如，考虑查询 “对于大学中所有讲授课程的教师，找出他们的名字以及讲授的所有课程id”，使用笛卡尔积连接和自然连接的命令分别是

```sql
select name, course_id
from instructor, teaches
where instructor.ID = teaches.ID;

select name, course_id
from instructor natural join teaches;
```

- 自然连接的运算结果不包含前缀，因为公共属性的值总是相同的，结果中就只有一份记录。
- 自然连接的公共属性不一定是主码，也就是可能具有重复值。这种情况下，对于这些重复值，自然连接会产生笛卡尔积式的组合。从另一个角度理解，自然连接的结果总是与先进行笛卡儿积，然后再使用公共属性相等的 where 语句筛选得到的结果相同。

**from多关系：join using**：有的时候，存在多个公共属性，但我们只希望按照其中一部分属性进行自然连接。考虑这个查询：列出教师的名字以及他们讲授的课程的名称。一个错误的命令是

```sql
select name, title
from instructor natural join teaches natural join course;
```

- 这个命令希望先通过 instructor 与 teaches 的自然连接得到 (name, course_id) ，然后再通过与 course 的自然连接得到 (name, course_id, title) 。
- 但问题在于，instructor 与 course 具有公共属性 dept_name。这样，第二次自然连接的公共属性除了 course_id 还有 dept_name。
- 查询结果中，只包括教师教授的本院系的课程。跨院系授课的情况被遗漏了。

正确的命令是使用 join using 关键字。join using 也可以看作是自然连接的一种构造形式。

```sql
select name, title
from (instructor natural join teaches) join course using (course_id); 
```

