---
layout: post
title:  "2.2 用户级、特权级和系统调用"
category: "xv6-book"
order: "9"
---

强隔离要求我们在操作系统和硬件之间确定一个硬边界。如果应用程序犯了一个错，我们不希望操作系统或其他应用程序因此故障。相反，操作系统应该能够清理这个故障的应用，并继续运行其他的应用。要达到这种强隔离，操作系统必须要求每个进程不能修改（甚至是不能读）操作系统的数据结构和指令，也不能访问其他进程的内存空间。

CPU 为强隔离提供了硬件支持。例如，RISC-V CPU 可以在三种模式下运行指令：机器模式（machine mode），特权模式（supervisor mode）和用户级（user mode）。机器模式下的指令具有完全的权限， CPU 开始运行时就处于机器模式下。这一模式通常是用来配置一台计算机的。xv6 只在机器模式下运行了少量指令，然后就切换到了特权模式。

特权模式下，CPU 可以执行特权指令，例如开启或禁用中断，读写一个装有页表地址的寄存器，等等。如果用户模式的进程试图运行特权指令，CPU 不会运行这些指令；而是会切换到特权模式，然后在特权模式下终止这个进程，因为它运行了不应该运行的指令。图 1.1 就展示了这一组织方式。一个应用只能运行用户模式的指令（例如将两个数字相加），因此被称作是运行在用户空间（user space）。特权模式下的软件还可以执行特权指令，因此被称作是运行在内核空间（kernel space）。运行在内核空间的软件就被称作内核（kernel）。

应用程序如果想要调用内核函数（例如 xv6 的系统调用），就必须转到内核。CPU 提供了一个特殊指令来将  CPU 从用户模式切换到特权模式，并从一个由内核指定的入口点进入内核。（RISC-V 中就是 ecall 指令）CPU 切换到特权模式后，内核就可以开始校验系统调用的参数（例如，检查进程传入的地址是不是它的内存空间的一部分），然后决定是拒绝执行还是开始执行。切换到特权模式时的入口点是由内核控制着的。这很关键：如果应用程序能够决定内核入口点，恶意的应用就可以从一个特定的点进入来跳过参数校验过程。