---
layout: post
title:  "2.1 抽象物理资源"
category: "xv6-book"
order: "8"
---

一个人遇见操作系统时问的第一个问题大概是：到底为什么需要它？也就是说，图 1.2 中的系统调用完全可以实现成库函数的形式，由应用链接使用。这种方案下，每个应用甚至都可以根据它自己的需要定制库函数。应用可以直接与硬件资源交互，并以最合适的方式使用这些资源（例如，达到更高的且可预测的性能）。一些为了嵌入设备或实时系统设计的操作系统确实是以这种方式组织的。

但这种“库方案”的缺点是，如果有超过一个应用在运行，这些应用必须表现正常。例如，每个应用必须周期性地让出 CPU，这样别的应用才能运行。如果各个应用都相互信任，而且自身没有缺陷的话，那么这种协同的时间共享机制也许没有问题。但是更经常的情况是，应用直接并不彼此信任，而且也很可能有缺陷。所以相比于协同机制，人们更想要较强的隔离机制。

为了实现强隔离机制，就有必要禁止应用直接访问敏感的硬件资源。作为替代，操作系统把这些资源抽象成服务，供应用使用。例如，Unix 应用与存储的交互仅能通过文件系统的 open, read, write, close 系统调用，而不能直接读写磁盘。操作系统来管理磁盘，并向应用提供了更便于使用的路径名。即使不考虑隔离，人们大概率也会认为使用路径名相比于直接使用磁盘是一个更方便的抽象。

类似地，Unix 在进程间透明地切换硬件 CPU，以及在必要时存储和恢复寄存器状态，从而应用就不需要关心时间共享。即使有的程序在死循环，这种透明性也能保证操作系统可以在进程间共享 CPU。

另一个例子是，Unix 进程使用 exec 来建立它们自己的内存镜像，而不是直接操作物理内存。这个过程中，操作系统来决定要把进程放在内存的什么位置。如果内存空间很紧张，操作系统可能甚至会把进程的部分数据存储在磁盘上。exec 还使用户能方便地用文件系统来存储可执行程序镜像。

进程间的许多通信是以文件描述符的方式发生的。文件描述符不仅通过抽象隐藏了很多细节（例如数据是在管道里还是存储在文件里），而且也为进程通信定义了简单的交互方式。例如，如果一个管道的一端的进程故障了，内核就会为另一端的进程生成一个 EOF 符。

图 1.2 中的系统调用接口同时考虑了编程者的便利和强隔离的可能性。Unix 接口并不是抽象资源的唯一方式，但它已经被证明是一个好的方式。