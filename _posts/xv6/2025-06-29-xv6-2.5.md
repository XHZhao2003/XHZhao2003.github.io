---
layout: post
title:  "2.5 进程概览"
category: "xv6-book"
order: "12"
---

xv6 使用页表（由硬件实现）来为每个进程提供地址空间。RISC-V 页表将一个虚拟地址（virtual address）翻译成一个物理地址（physical address）。RiSC-V 指令集使用的是虚拟地址，用页表进行翻译后，才是真正操作的物理地址，即主存上的地址。

![figure2.3](/assets/xv6/figure2.3.png)*图 2.3：进程的虚拟地址空间布局*

xv6 为每个进程维护了一个页表，这个页表定义了进程的地址空间。如图 2.3 所示，地址空间包括所有进程可用的用户内存（user memory）。从虚拟地址 0 处开始，首先是指令，然后是全局变量，然后是运行时栈，最后是程序可以按需扩展的堆区。限制地址空间的最大规模的有以下几个因素：RISC-V 的指针是 64 位的，而硬件在用页表翻译虚拟地址时只利用了其较低的 39 位，xv6 只利用了这 39 位中的 38 位。所以，最大的地址就是 2^38 - 1 = 0x3fffffffff，也就是 MAXVA [(kernel/riscv.h:363)](https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/riscv.h#L363) 。在地址空间的顶部，xv6 分别为跳板（trampoline）和陷阱帧（trapframe）各留存了一页。xv6 用这两页来进行与内核的切换。跳板包含了切入和切出内核的代码，陷阱帧用来存储/恢复进程的状态，详见第四章。

xv6 为每个进程保存了许多状态，用一个结构体 struct proc 汇总起来 [(kernel/proc.h:86)](https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/proc.h#L86) 。一个进程的内核状态中最关键的几个部分包括它的页表，内核栈以及运行状态。我们会用 p->xxx 来指代 proc 结构体的元素。例如 p->pagetable 就是指向一个进程的页表的指针。

每个进程都有一个执行线程来执行指令。一个线程可以被暂时挂起，然后被恢复继续执行。内核要在进程之间透明地切换，就是要挂起正在运行的线程并继续执行其他进程的线程。这些线程的大部分状态（局部变量，函数调用返回地址）都被存储在线程的栈中。每个进程具有两个栈：用户栈和内核栈（p->kstack）。当进程在执行用户态指令时，进程只使用用户栈，而内核栈为空。当进程（由于系统调用或者中断）进入内核，内核代码会在进程的内核栈上执行，此时它的用户栈还是存储着数据的，只是暂时不会被访问。所以，一个进程的线程总是在使用用户栈和使用内核栈之间切换。内核栈是与用户栈分开的（并且用户态代码也无法访问），从而即便进程损坏了它的用户栈，内核也能继续执行。

进程进行系统调用时，实际上是执行了 RISC-V 的 ecall 指令。这一指令提升了 CPU 的权限等级，并将程序计数器切换到内核定义好的入口点上。入口点处的代码会切换到内存栈，并执行系统调用对应的内核指令。系统调用完成后，内核切换回用户栈，执行 sret 指令来降低硬件等级，回到用户态，并继续执行原来的用户指令。进程的线程还有可能因为 I/O 操作在内核中阻塞住，然后在 I/O 完成后继续执行。

p->state 就表示了一个进程的状态：已分配（allocated）、准备运行（ready to run）、正在运行（running）、等待I/O（waiting for I/O）或正在退出（exiting）。

p->pagetable 以 RiSC-V 硬件所期待的形式存储了进程的页表。当进程在用户空间运行时，xv6 会让需要访问页表的硬件访问到进程的对应页表。一个进程的页表同时还用于记录一个进程实际已经被分配的物理页面。

总结一下，进程结合了两个理念：用地址空间使得程序拥有自己的内存，用线程使进程拥有自己的 CPU。当然这都是操作系统营造的假象。xv6 中，一个进程拥有一个页表和一个线程；但实际的操作系统中，一个进程可能拥有多个线程来利用多个 CPU。