---
layout: post
title:  "1.2 I/O和文件描述符"
category: "xv6-book"
order: "3"

---


一个文件描述符（file descriptor）是一个较小的整数，表示一个由内核管理的，进程可以进行读写的对象。文件描述符可以指定的是进程打开的文件、目录、设备，或者创建的管道，或者复制的一个已有的文件描述符。为了简单起见，我们将这些对象都称作是文件。文件描述对文件、管道、设备进行了抽象，隐藏了它们的差异，使它们都可以被看作是字节流。下面会将输入输出称为 I/O。

在 xv6 内部，内核为每个进程都维护了一个表，而文件描述符就是这个表上的索引。所以每个进程都有一个私有的文件描述符空间，文件描述符从 0 开始计数。按照惯例，文件描述符 0 表示标准输入，进程默认从这里读；1 表示标准输出，进程默认从这里写；2 表示标准错误，错误信息会默认写到这里。我们将要看到，Shell 就是利用了这一惯例来实现 I/O 重定向和管道流水线。Shell 确保进程总是有三个文件描述符 [(user/sh.c:151)](https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L151)，对于控制台来说就是默认的 0, 1, 2 描述符。

read 和 write 系统调用对文件描述符指定的文件进行读写。read(fd, buf, n) 调用从 fd 描述符表示的文件中读取至多 n 个字节，并拷贝到 buf 中，返回值是实际读取的字节数。指向文件的文件描述符都附带了一个偏移量。read 会从当前的文件偏移量处开始读取，读取完成后会根据实际读到的数量增加偏移量。当没有可读的字节了，read 就会返回 0 ，表示文件结束。

write(fd, buf, n) 调用向 fd 描述符表示的文件中写入 n 个字节，并返回实际写入的字节数。如果有错误发生，write 就可能写入少于 n 个字节。像 read 一样，write 也是在文件的当前偏移量处写入，并在写入后增加偏移量。每次写入都会从上一次离开的地方继续。

下面这段程序（展示了程序 cat 的本质）从标准输入读取，并复制写入到标准输出。如果发生错误，它就将错误信息写到标准错误。

``````c
char buf[512];
int n;
for(;;){
    n = read(0, buf, sizeof buf);
    if(n == 0)
        break;
    if(n < 0){
        fprintf(2, "read error\n");
        exit(1);
    }
    if(write(1, buf, n) != n){
        fprintf(2, "write error\n");
        exit(1);
    }
}
``````

实际上，这段程序（cat）并不知道它到底是读写文件，还是控制台的输入输出，还是一个管道。文件描述符的惯例，即 0, 1, 2 作为标准输入输出错误，允许 cat 可以这样简单实现。

close 系统调用释放一个文件描述符，使得这个数字可以被将来的 open, pipe, dup 系统调用重复利用（见下文）。最新被分配的文件描述符总是使用尽可能小的未被占用的文件描述符。

利用文件描述符与 fork 的交互可以很容易地实现 I/O 重定向。fork 创建子进程时，父进程的文件描述符表也会随着内存一起被拷贝，这样子进程就会拥有与父进程完全相同的文件描述符，以及打开的文件。exec 系统调用会替换进程的内存，但是会保留它的文件表和描述符。这一行为允许 Shell 来这样实现重定向（redirection）：先 fork，然后在子进程中重新打开文件描述符，再通过 exec 来运行沉痼。下面是当 Shell 处理 cat < input.txt 时，运行的代码的简化版本。

``````c
char *argv[2];

argv[0] = "cat";
argv[1] = 0;
if(fork() == 0) {
    close(0);
    open("input.txt", O_RDONLY);
    exec("cat", argv);
}
``````

在子进程关闭文件描述符 0 之后，open 保证会利用文件描述符 0 来指代 input.txt 文件。然后，cat 就利用文件描述符 0 （标准输入）来指代 input.txt 文件了。这一过程并没有改变父进程的文件描述符。

xv6 Shell 的 I/O 重定向实际上就是以这种方式工作的 [(user/sh.c:82)](https://github.com/mit-pdos/xv6-riscv/blob/riscv/user/sh.c#L82) 。回忆：在这一时刻，shell 已经 fork 了子进程，并且 runcmd 会调用 exec 来加载新的程序。

open 调用的第二个参数是一组标记位，来控制打开文件的行为，用比特位来表示。可能的取值在文件控制头中（fcntl header）定义了 [(kernel/fcntl.h:1-5)](https://github.com/mit-pdos/xv6-riscv/blob/riscv/kernel/fcntl.h#L1-L5)：O_RDONLY, O_WRONLY, O_RDWR, O_CREATE 和 O_TRUNC ，含义依次是，只读代开，只写代开，可读可写打开，文件不存在时创建，打开时清除文件内容。

现在应该很清楚为什么 fork 和 exec 两个系统调用应该分开了：这依次调用这两个调用之间，Shell 有机会重定向子进程的 I/O，且不对父进程的 I/O 造成影响。可以想象，如果这两个调用合并成一个 forkexec，那么系统调用的实现就显得尴尬。Shell 应该先在父进程中重定向 I/O，然后调用 forkexec，然后再在父进程中撤销这个重定向。或者，forkexec 可以接受关于 I/O 重定向的参数；或者也可以是每个程序自己接受关于重定向的参数。

尽管 fork 会拷贝文件描述符表，但文件描述符的文件偏移量在父子进程之间是共享的。考虑下面的例子：

``````c
if(fork() == 0) {
    write(1, "hello ", 6);
    exit(0);
} else {
    wait(0);
    write(1, "world\n", 6);
}
``````

这段程序结束时，文件描述符 1 所指的文件会包含数据 “hello world”。首先，父进程调用了 wait 来确保子程序先 write，父进程后 write。父进程 write 时，会接着子进程的内容之后继续写。利用这一行为，Shell 命令可以产生序列输出，例如 (echo hello; echo world) > output.txt

dup 系统调用会复制一个已有的文件描述符，返回一个新的文件描述符，指向相同的 I/O 对象。两个文件描述符会共享偏移量，就像 fork 复制的文件描述符一样。下面的代码也是会向文件中写入 hello world

``````c
fd = dup(1);
write(1, "hello ", 6);
write(fd, "world\n", 6);
``````

fork 和 dup 系统调用创建的新的文件描述符指向与原文件描述符相同的文件，也会共享偏移量。但除此之外，偏移量不会被共享，即使两个文件描述符指向相同的文件。dup 允许 Shell 实现类似这样的指令：ls existing-file non-existing-file > tmp1 2>&1。 2>&1 表示 Shell 会复制文件描述符 1，作为文件描述符 2 。这样，existing-file 的输出信息，non-existing-file 的错误信息就都会输出到 tmp1 文件中。xv6 的 Shell 还没有支持关于错误文件描述符的重定向，但现在你知道该如何实现了。

文件描述符是强大的抽象，它们将它们连接的文件的具体细节隐藏了：一个进程向文件描述符 1 写入时，它可能是在写入文件，或者在写入一个设备（例如控制台），或者是写入一个管道。