---
layout: post
title:  "3.2 内核地址空间"
category: "xv6-book"
order: "18"

---

xv6 为每个进程维护一个页表，用来描述进程的用户地址空间。xv6 还单独维护一个页表，用来描述内核的地址空间。内核会配置自己的地址空间的布局，并赋予自身对物理内存，以及在不同虚拟地址处的其他硬件资源的访问权限。图 3.3 展示了这一布局将内核的虚拟地址映射为物理地址。文件 [kernel/memlayout.h]([xv6-riscv/kernel/memlayout.h at riscv · mit-pdos/xv6-riscv](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/memlayout.h)) 声明了 xv6 内核内存布局中的常量。

![figure3.3](D:\其他资源\XHZhao2003.github.io\assets\xv6\figure3.3.png)*图 3.3：左图，xv6 的内核地址空间。RWX 分别表示 PTE 的读写执行权限。右侧，xv6 期望看到的 RISC-V 物理地址空间*

QEMU 模拟一个计算机，其 RAM (物理内存) 从物理地址 `0x80000000` 开始持续到 `0x86400000`，后者在 xv6 中称为 `PHYSTOP`。QEMU 模拟还包括一些 I/O 设备，例如硬盘接口。QEMU 将设备接口以内存映射 (memory-mapped) 控制寄存器的形式暴露给软件。这些设备在物理内存中处于 `0x80000000` 下方。内核通过读写特定的物理地址就可以与这些设备交互。第 4 章回解释 xv6 如何与这些设备交互。

内核获取 RAM 以及 内存映射设备的物理地址时使用的是直接映射。也就是，资源的虚拟地址就等于物理地址。例如，内核程序自身在虚拟地址和物理地址中都处于 `KERBASE=0x80000000` 中。直接映射简化了需要读写物理内存的内核代码。例如，当 fork 为子进程分配用户内存时，分配器会返回内存的物理地址，fork 在复制父进程的内存映像时，就可以直接使用物理地址。

有一些内核虚拟地址不是直接映射的：

- 跳表页，它被映射到了虚拟地址的顶部，用户态页表也将它映射到顶部。第 4 章会讨论跳表页的作用。但我们在这里看到了一种有趣的页表使用案例：一个（包含跳表代码的）物理页在内核虚拟地址空间中被映射了两次，一次在虚拟地址空间的顶部，另一次是直接映射。
- 内核栈页，每个进程都有自己的内核栈。内核栈也被映射到虚拟地址空间的顶部。内核栈在虚拟地址空间中从高向低生长，xv6 在每个内核栈的底部放置了一个未被映射的守卫页（guard page）。守卫页的 PTE 是无效的（也就是 `PTE_V` 没有被设置），所以如果内核栈溢出了，就很可能会触发异常。如果没有守卫页，内核栈移除就有可能覆写其他的内核内存，导致错误操作。相比之下，产生一个故障是更好的。

尽管内核将栈映射到了顶部，内核栈也可以通过直接映射访问。一种替代的方案是只使用直接映射。然而这种安排下，要设置守卫页，就需要控制虚拟地址是否映射到物理地址。这使问题更困难了。

内核为跳表页和内核内容设置了 `PTE_R, PTEX` 权限，从这些页中读和执行指令。内核为其他页都设置了 `PTE_R, PTE_W` 指令，从而可以读写内存。守卫页没有设置 `PTE_V`，是无效的。